var mongodb = require('mongodb');
var ObjectID = require('mongodb').ObjectID;

exports.MongoSaveHandler = MongoSaveHandler;

function MongoSaveHandler(db, reqBody, callback) {
    this.db = db;
    this.entities = reqBody.entities;
    this.saveOptions = reqBody.saveOptions;
    this.metadata = reqBody.metadata;
    this.callback = callback;
    // this.saveMap - created later

    this._saveCountPending = 0;
    this._allCallsCompleted = false;
    this._insertedKeys = [];
    this._updatedKeys = [];
    this._deletedKeys = [];
    this._keyMappings = [];
    this._entitiesCreatedOnServer = [];
    this._possibleFixupMap = {};

};

MongoSaveHandler.save = function(db, reqBody, callback) {
    var saveHandler = new MongoSaveHandler(db, reqBody, callback);
    saveHandler.save();
};

// virtual method - returns nothing
//MongoSaveHandler.prototype.beforeSaveEntity = function(entity)


// virtual method - returns saveMap - saveMap is keyed by entityType with each value being an array of entities.
//MongoSaveHandler.prototype.beforeSaveEntities = function(callback)


MongoSaveHandler.prototype.save = function() {
    var beforeSaveEntity = this.beforeSaveEntity && this.beforeSaveEntity.bind(this);

    this.saveMap = groupBy(this.entities, function(e) {
        if (beforeSaveEntity) {
            if (beforeSaveEntity(e)) {
                return e.entityAspect.entityTypeName;
            }
        } else {
            return e.entityAspect.entityTypeName;
        }
    });

    var beforeSaveEntities = this.beforeSaveEntities && this.beforeSaveEntities.bind(this);
    var saveCoreFn = saveCore.bind(this);
    if (beforeSaveEntities) {
        beforeSaveEntities(saveCoreFn);
    } else {
        saveCoreFn();
    }

};

MongoSaveHandler.prototype.registerEntityType= function(entityTypeName, mongoCollectionName, autoGeneratedKeyType, dataProperties ) {
    var entityTypeName = this.qualifyTypeName(entityTypeName);
    var entityType = this.metadata[entityTypeName];
    if (!entityType) {
        entityType = { name: entityTypeName };
        this.metadata[entityTypeName] = entityType;
    }
    entityType.defaultResourceName = mongoCollectionName || entityType.defaultResourceName;
    entityType.autoGeneratedKeyType = autoGeneratedKeyType || entityType.autoGeneratedKeyType || "None";
    entityType.dataProperties = dataProperties || entityType.dataProperties || [];
};

MongoSaveHandler.prototype.addToSaveMap = function(entity, entityTypeName, entityState) {
    var entityTypeName = this.qualifyTypeName(entityTypeName);
    entity.entityAspect = {
        entityTypeName: entityTypeName,
        entityState: entityState || "Added",
        wasCreatedOnServer: true
    };

    var entityList = this.saveMap[entityTypeName];
    if (entityList) {
        entityList.push(entity);
    } else {
        this.saveMap[entityTypeName] = [ entity ];
    }

    return entity;
};

MongoSaveHandler.prototype.qualifyTypeName = function(entityTypeName) {
    if ((entityTypeName.indexOf(":#") !== -1) || (!this.metadata.defaultNamespace)) {
        return entityTypeName;
    } else {
        return entityTypeName + ":#" + this.metadata.defaultNamespace;
    }
}


// will be bound to MongoSaveHandler instance at runtime.
function saveCore() {

    var pendingCollections = objectMap(this.saveMap, this._prepareCollection.bind(this));
    this._fixupFks(pendingCollections);
    var that = this;
    if (pendingCollections.length === 0) {
        this._invokeCompletedCallback();
    } else {
        pendingCollections.forEach(function(pc) {
            that._saveCollection(pc);
        });
        this._allCallsCompleted = true;
    }
};


MongoSaveHandler.prototype._prepareCollection = function(entityTypeName, entities) {
    var insertDocs = [];
    var updateDocs = [];
    var deleteDocs = [];

    var entityType = this.metadata[entityTypeName];
    if (!entityType) {
        this._raiseError(new Error("Unable to locate server side metadata for an EntityType named: " + entityTypeName));
    }
    var resourceName = entityType.defaultResourceName;

    var that = this;
    entities.forEach(function(e) {
        var entityAspect = e.entityAspect;
        // needed because we need to strip the entityAspect off the entity for inserts.
        entityAspect.entity = e;
        var entityState = entityAspect.entityState;
        // TODO: we really only need to coerce every field on an insert
        // only selected fields are needed for update and delete.
        that._coerceData(e, entityType, resourceName);
        var entityKey = { entityTypeName: entityTypeName, _id: e._id } ;
        entityAspect.entityKey = entityKey;
        if (entityState === "Added") {
            delete e.entityAspect;

            var autoGeneratedKeyType = entityType.autoGeneratedKeyType;
            if (autoGeneratedKeyType && autoGeneratedKeyType !== "None") {

                var keyDataType = entityType.keyDataType;
                if (keyDataType === "Guid") {
                    e._id = createGuid();
                } else if (keyDataType == "MongoObjectId") {
                    // instead of omitting the _id and having mongo update it, we want to set it ourselves so that we can do
                    // fk fixup before going async
                    e._id = new ObjectID();
                } else {
                    that._raiseError(new Error("ObjectIds and Guids are the only autoGenerated key types that Breeze currently supports, not: " + keyDataType));
                    return;
                }
            }

            // entityKey._id may be null/undefined for entities created only on the server side - so no need for keyMapping
            if (entityKey._id == null) {
                entityKey._id = e._id;
            } else if (entityKey._id !== e._id) {
                keyMapping = { entityTypeName: entityTypeName, tempValue: entityKey._id, realValue: e._id };
                that._keyMappings.push(keyMapping);
            }

            var insertDoc = {
                entity: e,
                entityAspect: entityAspect
            };
            insertDocs.push(insertDoc);
        } else if (entityState === "Modified") {
            var criteria = { "_id": e._id };
            if (entityType.concurrencyProp) {
                // Note that the Breeze client will insure that the current value has been updated.
                // so no need to do that here
                var propName = entityType.concurrencyProp.name;
                criteria[propName] = entityAspect.originalValuesMap[propName];
            }
            var setMap;
            if (entityAspect.forceUpdate) {
                setMap = extend({}, e);
                // remove fields that we don't want to 'set'
                delete setMap.entityAspect;
                delete setMap._id;
            } else {
                setMap = {};
                Object.keys(entityAspect.originalValuesMap).forEach(function(k) {
                    setMap[k] = e[k];
                });
            }

            var updateDoc = {
                criteria: criteria,
                setOps: { $set: setMap },
                entityAspect: entityAspect,
                hasConcurrencyCheck: !!entityType.concurrencyProp
            };
            updateDocs.push(updateDoc);
        } else if (entityState = "Deleted") {
            var criteria = { "_id": e._id };
            // we don't bother with concurrency check on deletes
            // TODO: we may want to add a 'switch' for this later.
            var deleteDoc = {
                criteria: criteria,
                entityAspect: entityAspect
            };
            deleteDocs.push(deleteDoc);
        }
    });
    return {
        resourceName: resourceName,
        inserts: insertDocs,
        updates: updateDocs,
        deletes: deleteDocs
    };

};

MongoSaveHandler.prototype._saveCollection = function(pc) {
    this._saveCountPending += pc.inserts.length + pc.updates.length + pc.deletes.length;
    var saveOptions = { safe: true }
    var that = this;
    this.db.collection(pc.resourceName, {strict: true} , function (err, collection) {
        pc.inserts.forEach(function (iDoc) {
            collection.insert(iDoc.entity, saveOptions, function(err, object) {
                that._handleInsert(iDoc, err, object);
            });
        });
        pc.updates.forEach(function (uDoc) {
            collection.update( uDoc.criteria, uDoc.setOps, saveOptions, function(err, object) {
                that._handleUpdate(uDoc, err, object);
            })
        });
        pc.deletes.forEach(function (dDoc) {
            collection.remove( dDoc.criteria, true, function(err, object) {
                that._handleDelete(dDoc, err, object);
            })
        });
    });
};

MongoSaveHandler.prototype._coerceData = function(entity, entityType) {
    var that = this;
    entityType.dataProperties.forEach(function(dp) {
        var dt = dp.dataType;
        // if this is an fk column and it has a value
        // create a map of entities that may need to be fixed up - keyed by the tempFkValue ( which may be a realFkValue already).
        // Note this works because in mongo all fkValues must refer to an _id field as the paired key.
        if (dp.isFk && entity[dp.name]) {
            var fk = entity[dp.name];
            if (dp.name === "_id") {
                that._raiseError(new Error("The '_id' property cannot itself be a foreignKey in a mongoDb - Please check you metadata for entityType: " + entityType.name));
            }
            var possibleFixups = that._possibleFixupMap[fk];
            if (!possibleFixups) {
                possibleFixups = [];
                that._possibleFixupMap[fk] = possibleFixups;
            }
            possibleFixups.push( { _id: entity._id, fkProp: dp.name  });
        }

        if (dp.name === "_id") {
            entityType.keyDataType = dt;
        }
        if (dp.isConcurrencyProp) {
            entityType.concurrencyProp = dp;
        }

        var val = entity[dp.name];
        if (val == null) {
            // this allows us to avoid inserting a null.
            // TODO: think about an option to allow this if someone really wants to.
            delete entity[dp.name];
            return;
        }

        if (dt === "MongoObjectId") {
            if (val) {
                try {
                    entity[dp.name] = ObjectID.createFromHexString(val);
                } catch (err) {
                    that._raiseError(new Error("Unable to convert the value: '" + val + "' to a Mongo ObjectID"));
                }
            }
        } else if (dt === "DateTime" || dt === "DateTimeOffset") {
            if (val) {
                entity[dp.name] = new Date(Date.parse(val));
            }
        }
    })
};

MongoSaveHandler.prototype._handleInsert = function(insertDoc, err, insertedObjects) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(insertDoc, this._insertedKeys);
    if ((!insertedObjects) || insertedObjects.length !== 1) {
        this._raiseError(new Error("Not inserted: " + formatEntityKey(entityKey)));
    }
    this._checkIfCompleted();
};

MongoSaveHandler.prototype._handleUpdate = function (updateDoc, err, wasUpdated) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(updateDoc, this._updatedKeys);
    if (!wasUpdated) {
        var msg = updateDoc.hasConcurrencyCheck
            ? ". This may be because of the concurrency check performed during the save."
            : ".";
        this._raiseError(new Error("Not updated: " + formatEntityKey(entityKey) + msg));
    }
    this._checkIfCompleted();
};

MongoSaveHandler.prototype._handleDelete = function (deleteDoc, err, wasDeleted) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(deleteDoc, this._deletedKeys);
    if (!wasDeleted) {
        this._raiseError(new Error("Not deleted: " + formatEntityKey(entityKey)));
    }
    this._checkIfCompleted();
};

MongoSaveHandler.prototype._handleSave = function(doc, keyCollection) {

    var entityAspect = doc.entityAspect;
    var entityKey = entityAspect.entityKey;
    if (entityAspect.wasCreatedOnServer) {
        entity = entityAspect.entity;
        entity.$type = entityAspect.entityTypeName;
        this._entitiesCreatedOnServer.push(entity);
    }
    keyCollection.push(entityKey);
    return entityKey;
};

MongoSaveHandler.prototype._fixupFks = function(pcs) {
    if (this._keyMappings.length === 0) return;
    // pendingMap is a map of _id to pendingDoc
    var pendingMap = {};
    pcs.forEach(function(pc) {
        pc.inserts.concat(pc.updates).forEach(function(doc) {
            pendingMap[doc.entityAspect.entityKey._id] = doc;
        })
    });

    // kmMap is a map of tempFkValue -> keyMapping
    var kmMap = {};
    this._keyMappings.forEach(function(km) {
        kmMap[km.tempValue] = km;
    });

    // _possibleFixupMap is a map of fkValue -> [] of possibleFixups { _id:, fkProp: }
    for (fkValue in this._possibleFixupMap) {
        var km = kmMap[fkValue];
        if (km) {
            // if we get to here we know that we have an fk or fks that need updating
            var realValue = km.realValue;
            var pendingFixups = this._possibleFixupMap[fkValue];
            pendingFixups.forEach(function(pendingFixup) {
                // update the pendingDoc with the new real fkValue
                // next line is for debug purposes
                pendingFixup.fkValue = realValue;
                var pendingDoc = pendingMap[pendingFixup._id];
                if (pendingDoc.criteria) {
                    pendingDoc.setOps.$set[pendingFixup.fkProp] = realValue;
                } else {
                    pendingDoc.entity[pendingFixup.fkProp] = realValue;
                }
            });
        }
    }
};

MongoSaveHandler.prototype._raiseError = function(error) {
    if (this._isAllDone) return;
    this._isAllDone = true;
    this.callback(error);
};

MongoSaveHandler.prototype._checkIfError = function(err) {
    if (err) {
        this._raiseError(err);
    }
    return err != null;
};

MongoSaveHandler.prototype._checkIfCompleted = function() {
    if (this._isAllDone) return;
    this._saveCountPending -= 1;
    if (this._saveCountPending > 0) return;
    if (!this._allCallsCompleted) return;
    this._invokeCompletedCallback();
};

MongoSaveHandler.prototype._invokeCompletedCallback=function() {
    this._isAllDone = true;
    this.callback(null, {
        insertedKeys: this._insertedKeys,
        updatedKeys:  this._updatedKeys,
        deletedKeys:  this._deletedKeys,
        keyMappings:  this._keyMappings,
        entitiesCreatedOnServer: this._entitiesCreatedOnServer
    });
}

function formatEntityKey(ek) {
    return ek.entityTypeName + ": " + ek._id;
}

function extend(target, source) {
    if (!source) return target;
    for (var name in source) {
        if (source.hasOwnProperty(name)) {
            target[name] = source[name];
        }
    }
    return target;
}

// returns an array with each item corresponding to the kvFn eval'd against each prop.
function objectMap(obj, kvFn) {
    var results = [];
    for (var key in obj) {
        if ( obj.hasOwnProperty(key)) {
            var r = kvFn(key, obj[key]);
            results.push(r);
        }
    }
    return results;
}

function groupBy(arr, keyFn) {
    var groups = {};
    arr.forEach(function (v) {
        var key = keyFn(v);
        if (key !== undefined) {
            var group = groups[key];
            if (!group) {
                group = [];
                groups[key] = group;
            }
            group.push(v);
        }
    })
    return groups;
}

function createGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

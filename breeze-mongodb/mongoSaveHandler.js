/*
 * Copyright 2014 IdeaBlade, Inc.  All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the IdeaBlade Breeze license, available at http://www.breezejs.com/license
 *
 * Author: Jay Traband
 */
var mongodb = require('mongodb');
var ObjectID = require('mongodb').ObjectID;

exports.MongoSaveHandler = MongoSaveHandler;
exports.version = "1.4.13";

function MongoSaveHandler(db, reqBody, callback) {
    this.db = db;

    this.entities = reqBody.entities || [];
    this.saveOptions = reqBody.saveOptions;
    this.metadata = reqBody.metadata || {};
    this.callback = callback;
    this.saveMap = {};

    // DEVELOPER INTERCEPTORS
    // `this.beforeSaveEntity(entity)` interceptor method - returns true if should save the entity
    // Called for each individual entity in the client save request
    // 'this' is bound to the current saveHandler instance

    // `this.beforeSaveEntities(continuerSave)` interceptor method - returns nothing
    // Called after 'this.saveMap` has been loaded with the entities to save
    // after `beforeSaveEntity` voted on them and before the breeze save processing.
    // Can evaluate 'this.saveMap' which is a hash of entities to save,
    // keyed by entityType,  with each value being an array of entities of that type.
    // Call 'continueSave' after doing your thing ... assuming you want to continue
    // else call 'this._raiseError(err) to report error to the client
    // 'this' is bound to the current saveHandler instance

    // `this.afterSaveEntity(success)` interceptor method - returns nothing
    // Called after all mongo save operations have returned successfully
    // Call 'success' after doing your thing ...
    // else call 'this._raiseError(err) to report error to the client
    // 'this' is bound to the current saveHandler instance

    // semi-private members
    this._allCallsCompleted = false;
    this._isAllDone = false;
    this._insertedKeys = [];
    this._updatedKeys = [];
    this._deletedKeys = [];
    this._keyMappings = [];
    this._entitiesCreatedOnServer = [];
    this._possibleFixupMap = {};
    this._saveCountPending = 0;

    this.saveResult = {
        insertedKeys: this._insertedKeys,
        updatedKeys:  this._updatedKeys,
        deletedKeys:  this._deletedKeys,
        keyMappings:  this._keyMappings,
        entitiesCreatedOnServer: this._entitiesCreatedOnServer
    };
}

MongoSaveHandler.save = function(db, reqBody, callback) {
    var saveHandler = new MongoSaveHandler(db, reqBody, callback);
    saveHandler.save();
};

var fn = MongoSaveHandler.prototype;

/////// Pre-save configuration /////////

// interceptor method - returns true if should save the entity
// 'this' is bound to the current saveHandler instance
//this.beforeSaveEntity = function(entity)

// interceptor method - returns nothing
// 'this' is bound to the current saveHandler instance
// Can evaluate this.saveMap hash of entities to save,
// keyed by entityType with each value being an array of entities of that type.
// call 'continueSave' after doing your thing ... assuming you want to continue
// else call 'this._raiseError(err) to report error to the client
//this.beforeSaveEntities = function(continueSave)

// interceptor method - returns nothing
// 'this' is bound to the current saveHandler instance
// call 'success' after doing your thing ...
// else call 'this._raiseError(err) to report error to the client
//this .afterSaveEntities = function(success)

fn.registerEntityType= function(entityTypeName, mongoCollectionName, autoGeneratedKeyType, dataProperties ) {
    entityTypeName = this.qualifyTypeName(entityTypeName);
    var entityType = this.metadata[entityTypeName];
    if (!entityType) {
        entityType = { name: entityTypeName };
        this.metadata[entityTypeName] = entityType;
    }
    entityType.defaultResourceName = mongoCollectionName || entityType.defaultResourceName;
    entityType.autoGeneratedKeyType = autoGeneratedKeyType || entityType.autoGeneratedKeyType || "None";
    entityType.dataProperties = dataProperties || entityType.dataProperties || [];
};

// A beforeSave method could call to add an entity-to-save to this.saveMap
fn.addToSaveMap = function(entity, entityTypeName, entityState) {
    entityTypeName = this.qualifyTypeName(entityTypeName);
    entity.entityAspect = {
        entityTypeName: entityTypeName,
        entityState: entityState || "Added",
        wasCreatedOnServer: true
    };

    var entityList = this.saveMap[entityTypeName];
    if (entityList) {
        entityList.push(entity);
    } else {
        this.saveMap[entityTypeName] = [ entity ];
    }

    return entity;
};

fn.qualifyTypeName = function(entityTypeName) {
    if ((entityTypeName.indexOf(":#") !== -1) || (!this.metadata.defaultNamespace)) {
        return entityTypeName;
    } else {
        return entityTypeName + ":#" + this.metadata.defaultNamespace;
    }
};

////////// Save Operation ///////////////
fn.save = function() {
    if (this._buildSaveMap()) return;
    var saveCoreFn = saveCore.bind(this);
    if (this.beforeSaveEntities) {
        try {
            this.beforeSaveEntities.bind(this)(saveCoreFn);
        } catch (err){
            err.message = "save failed in 'beforeSaveEntities' with error '"+err.message+"'";
            this._raiseError(err);
        }
    } else {
        saveCoreFn();
    }
};

// 'this' is bound to MongoSaveHandler instance at runtime (see fn.save())
function saveCore() {

    var that = this;
    var pendingCollections = [];
    if (this._reviewMetadataForSave()){return;}
    if (this._objectMap(this.saveMap, this._prepareCollection.bind(this), pendingCollections)) {return;}

    try {
        that._fixupFks(pendingCollections);
    } catch (err){
        that._raiseError(err);
        return;
    }

    if (pendingCollections.length === 0) {
        that._invokeCompletedCallback();
    } else {
        pendingCollections.forEach(function(pc) {
            if (that._isAllDone) return;
            that._saveCollection(pc);
        });
    }
    ////// call afterSave ////////
    that._allCallsCompleted = true;
}

fn._buildSaveMap = function (){
    var beforeSaveEntity = this.beforeSaveEntity && this.beforeSaveEntity.bind(this);
    var kf1 = function(e) { return e.entityAspect.entityTypeName;};
    var kf2 = function(e) { return beforeSaveEntity(e) ? kf1(e) : undefined; };
    var keyFn =  beforeSaveEntity ? kf2 : kf1;
    var errPrefix = "save failed in 'beforeSaveEntity'";
    return this._groupBy(this.entities, keyFn, this.saveMap = {}, errPrefix);
};

fn._coerceData = function(entity, entityType) {
    var that = this;
    return that._forEach(entityType.dataProperties, coerceProp);

    function coerceProp(dp) {
        var msg;
        var dt = dp.dataType;
        var dpn = dp.name;
        var val = entity[dpn];
        // if this is an fk column and it has a value
        // create a map of entities that may need to be fixed up - keyed by the tempFkValue ( which may be a realFkValue already).
        // Note this works because in mongo all fkValues must refer to an _id field as the paired key.
        if (dp.isFk && val) {
            var fk = entity[dpn];
            var fus = that._possibleFixupMap[fk];
            if (!fus) {
                that._possibleFixupMap[fk] = fus = [];
            }
            fus.push( { _id: entity._id, fkProp: dpn  });
        }
        if (val == null) {
            // this allows us to avoid inserting a null.
            // TODO: think about an option to allow this if someone really wants to.
            // [WB: WHAT IF THEY WANT A NULL?!? BAD IDEA JUST TO SAVE A LITTLE SPACE
            //      IF THEY DON'T WANT IT, THEY SHOULD STRIP THEMSELVES BEFORE SENDING
            //      OR IN THE BeforeSaveEntity]
            delete entity[dpn];
            return;
        }
        try {
            if (dt === "MongoObjectId") {
                entity[dpn] = ObjectID.createFromHexString(val);
            } else if (dt === "DateTime" || dt === "DateTimeOffset") {
                entity[dpn] = new Date(Date.parse(val));
            }
        } catch (err) {
            msg = "Unable to convert the "+entityType.name+"."+dpn+" value: '" + val + "' to a "+dt;
            that._raiseError({statusCode: 400, message: msg});
        }
    }
};

// 'pcs' are 'pendingCollections' - the set of insert/update/delete instructions
fn._fixupFks = function(pcs) {
    if (this._isAllDone) { return true; }// stop processing
    if (this._keyMappings.length === 0) { return false; }// continue processing

    // pendingMap is a map of _id to pendingDoc
    // for all inserts and updates
    var pendingMap = {};
    pcs.forEach(function(pc) {
        pc.inserts.concat(pc.updates)
        .forEach(function(doc) {
            pendingMap[doc.entityAspect.entityKey._id] = doc;
        })
    });

    // kmMap is a map of tempFkValue -> keyMapping
    var kmMap = {};
    this._keyMappings.forEach(function(km) {
        kmMap[km.tempValue] = km;
    });

    // _possibleFixupMap is a map of fkValue -> [] of possibleFixups { _id:, fkProp: }
    for (var fkValue in this._possibleFixupMap) {
        var km = kmMap[fkValue];
        if (km) {
            // if we get to here we know that we have an fk or fks that need updating
            var realValue = km.realValue;
            var pendingFixups = this._possibleFixupMap[fkValue];
            pendingFixups.forEach(function(pendingFixup) {
                // update the pendingDoc with the new real fkValue
                // next line is for debug purposes
                pendingFixup.fkValue = realValue;
                var pendingDoc = pendingMap[pendingFixup._id];
                if (pendingDoc.criteria) {
                    pendingDoc.setOps.$set[pendingFixup.fkProp] = realValue;
                } else {
                    pendingDoc.entity[pendingFixup.fkProp] = realValue;
                }
            });
        }
    }
};

// For entities of a given EntityType
// prepare the docs to insert/update/delete from a collection
fn._prepareCollection = function(entityTypeName, entities) {

    var entityType = this.metadata[entityTypeName];
    var insertDocs = [];
    var updateDocs = [];
    var deleteDocs = [];

    var that = this;
    that._forEach(entities, prepEntity, "Save failed preparing '"+entityType+"' entities. ");

    return {
        entityType: entityType,
        collectionName:  entityType.collectionName,
        inserts: insertDocs,
        updates: updateDocs,
        deletes: deleteDocs
    };

    function prepEntity(e) {
        var msg;
        // TODO: we really only need to coerce every field on an insert
        // only selected fields are needed for update and delete.
        // Coerce before using _id because that's one of the properties it parses
        that._coerceData(e, entityType);

        // hold entityAspect because we must strip it from an inserted entity.
        var entityAspect = e.entityAspect;
        entityAspect.entity = e;

        var entityKey = { entityTypeName: entityTypeName, _id: e._id };
        entityAspect.entityKey = entityKey;

        var criteria;

        switch(entityAspect.entityState) {
            case "Added":
                var autoGeneratedKeyType = entityType.autoGeneratedKeyType;
                if (autoGeneratedKeyType && autoGeneratedKeyType !== "None") {

                    var keyDataType = entityType.keyDataType;
                    if (keyDataType === "Guid") {
                        e._id = createGuid();
                    } else if (keyDataType == "MongoObjectId") {
                        // instead of omitting the _id and having mongo update it, we want to set it ourselves so that we can do
                        // fk fixup before going async
                        e._id = new ObjectID();
                    } else {
                        msg = "ObjectIds and Guids are the only autoGenerated key types that Breeze currently supports, not: " + keyDataType;
                        that._raiseError(new Error(msg));
                        return;
                    }
                }

                // entityKey._id may be null/undefined for entities created only on the server side - so no need for keyMapping
                if (entityKey._id == null) {
                    entityKey._id = e._id;
                } else if (entityKey._id !== e._id) {
                    var keyMapping = { entityTypeName: entityTypeName, tempValue: entityKey._id, realValue: e._id };
                    that._keyMappings.push(keyMapping);
                }

                delete e.entityAspect; // Don't want to insert that!
                var insertDoc = {
                    entity: e,
                    entityAspect: entityAspect
                };
                insertDocs.push(insertDoc);
                break;

            case "Modified":
                criteria = { "_id": e._id };
                if (entityType.concurrencyProp) {
                    // Note that the Breeze client will insure that the current value has been updated.
                    // so no need to do that here
                    var propName = entityType.concurrencyProp.name;
                    criteria[propName] = entityAspect.originalValuesMap[propName];
                }
                var setMap = {};
                if (entityAspect.forceUpdate) {
                    setMap = extend({}, e);
                    // remove fields that we don't want to 'set'
                    delete setMap.entityAspect;
                    delete setMap._id;
                } else {
                    Object.keys(entityAspect.originalValuesMap).forEach(function (k) {
                        setMap[k] = e[k];
                    });
                }

                var updateDoc = {
                    criteria: criteria,
                    setOps: { $set: setMap },
                    entityAspect: entityAspect,
                    hasConcurrencyCheck: !!entityType.concurrencyProp
                };
                updateDocs.push(updateDoc);
                break;

            case "Deleted":
                criteria = { "_id": e._id };
                // we don't bother with concurrency check on deletes
                // TODO: we may want to add a 'switch' for this later.
                var deleteDoc = {
                    criteria: criteria,
                    entityAspect: entityAspect
                };
                deleteDocs.push(deleteDoc);
                break;
            default:
                msg = "Unknown save operation request, entityState = " + entityAspect.entityState;
                that._raiseError({statusCode: 400, message: msg});
                return;
        }
    }
};

// Validate and massage metadata in this save
// only reviews metadata involved in this save
fn._reviewMetadataForSave = function (){
    var that = this;
    return that._forEach(Object.keys(this.saveMap), reviewType);

    function reviewType(typeName) {
        var msg;
        var entityType = that.metadata[typeName];
        if (!entityType) {
            msg = "Unable to locate server side metadata for an EntityType named: " + typeName;
            that._raiseError({statusCode: 400, message: msg});
            return null;
        }

        entityType.collectionName = entityType.collectionName || entityType.defaultResourceName;

        return that._forEach(entityType.dataProperties, reviewProperties);

        function reviewProperties(dp) {
            var dt = dp.dataType;

            if (dp.name === "_id") {
                entityType.keyDataType = dt;
                if (dp.isFk) {
                    msg = "The '" + typeName + "._id' property cannot itself be a foreignKey in a mongoDb - Please check your metadata.";
                    that._raiseError(new Error(msg));
                    return
                }
            }
            if (dp.isConcurrencyProp) {
                entityType.concurrencyProp = dp;
            }
        }
    }
};

fn._saveCollection = function(pc) {
    this._saveCountPending += pc.inserts.length + pc.updates.length + pc.deletes.length;
    var saveOptions = { safe: true };
    var that = this;
    this.db.collection(pc.collectionName, {strict: true} , function (err, collection) {
        if (err) {
            err.message = err.message.replace(/ Currently in safe mode\./,'');
            var msg = "Save failed to find the db collection for '" + pc.entityType.entityTypeName +
                      "' because " + err.message;
            err = { statusCode: 400, message: msg, error: err };
            that._raiseError(err);
            return;
        }

        pc.inserts.forEach(function (iDoc) {
            collection.insert(iDoc.entity, saveOptions, function(err, object) {
                that._handleInsert(iDoc, err, object);
            });
        });
        pc.updates.forEach(function (uDoc) {
            collection.update( uDoc.criteria, uDoc.setOps, saveOptions, function(err, object) {
                that._handleUpdate(uDoc, err, object);
            })
        });
        pc.deletes.forEach(function (dDoc) {
            collection.remove( dDoc.criteria, true, function(err, object) {
                that._handleDelete(dDoc, err, object);
            })
        });
    });
};

fn._handleInsert = function(insertDoc, err, insertedObjects) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(insertDoc, this._insertedKeys);
    if ((!insertedObjects) || insertedObjects.length !== 1) {
        this._raiseError(new Error("Not inserted: " + formatEntityKey(entityKey)));
    }
    this._checkIfCompleted();
};

fn._handleUpdate = function (updateDoc, err, wasUpdated) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(updateDoc, this._updatedKeys);
    if (!wasUpdated) {
        var msg = updateDoc.hasConcurrencyCheck
            ? ". This may be because of the concurrency check performed during the save."
            : ".";
        this._raiseError(new Error("Not updated: " + formatEntityKey(entityKey) + msg));
    }
    this._checkIfCompleted();
};

fn._handleDelete = function (deleteDoc, err, wasDeleted) {
    if (this._checkIfError(err)) return;
    var entityKey = this._handleSave(deleteDoc, this._deletedKeys);
    if (!wasDeleted) {
        this._raiseError(new Error("Not deleted: " + formatEntityKey(entityKey)));
    }
    this._checkIfCompleted();
};

fn._handleSave = function(doc, keyCollection) {

    var entityAspect = doc.entityAspect;
    var entityKey = entityAspect.entityKey;
    if (entityAspect.wasCreatedOnServer) {
        var entity = entityAspect.entity;
        entity.$type = entityAspect.entityTypeName;
        this._entitiesCreatedOnServer.push(entity);
    }
    keyCollection.push(entityKey);
    return entityKey;
};

/////// UTILITIES ///////

fn._checkIfError = function(err) {
    if (err) {
        this._raiseError(err);
    }
    return err != null;
};

// Called within a saveCollection callback
fn._checkIfCompleted = function() {
    if (this._isAllDone) return;            // save already terminated the entire saveChanges operation
    this._saveCountPending -= 1;            // this save call is done; decrement the count
    if (this._saveCountPending > 0) return; // awaiting more mongoDb save results
    if (!this._allCallsCompleted) return;   // might not have issued all mongoDb save calls yet
    this._invokeCompletedCallback();        // we really ARE done; wrap up the save
};

// Safe array iterator
// Terminates if f() raises or throws error.
// f() can _raiseError() with status other than 500.
// Returns TRUE if caller should STOP (false to continue)
fn._forEach = function(src, f, errPrefix){
    if (this._isAllDone) { return true; }
    try {
        for (var i=0, len=src.length; i < len; i++){
            f(src[i]);
            if (this._isAllDone) { return true; }
        }
    } catch (err){
        errPrefix = (errPrefix || 'Save failed') + ' with error: ';
        err.message = errPrefix + err.message;
        this._raiseError(err);
        return true;
    }
    return false;
};

// Safely iterate over array pushing values into arrays in
// the 'groups' object grouped by the key returned from keyFn()
// kvFn(key, value) turns key and value into a result to push
// Terminates if keyFn() raises or throws error.
// keyFn() can _raiseError() with status other than 500.
// Returns TRUE if caller should STOP (false to continue)
fn._groupBy = function(arr, keyFn, groups, errPrefix) {
    groups = groups || {};
    return this._forEach(arr, grouper, errPrefix);

    function grouper (v) {
        var key = keyFn(v);
        if (key !== undefined) {
            var group = groups[key];
            if (group){
                group.push(v)
            } else {
                groups[key] = [v];
            }
        }
    }
};

// Safely iterate over object pushing kvFn() result into map array
// kvFn(key, value) turns key and value into a result to push
// Terminates if kvFn() raises or throws error.
// kvFn() can _raiseError() with status other than 500.
// Returns TRUE if caller should STOP (false to continue)
fn._objectMap = function(obj, kvFn, map, errPrefix) {
    if (this._isAllDone) { return true; }
    try {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                var r = kvFn(key, obj[key]);
                if (this._isAllDone) { return true; }
                map.push(r);
            }
        }
    } catch (err){
        errPrefix = (errPrefix || 'Save failed') + ' with error: ';
        err.message = errPrefix + err.message;
        this._raiseError(err);
        return true;
    }
    return false;
};


// called when all mongo save operations have completed
fn._invokeCompletedCallback=function() {
    var success = function (){
        this._isAllDone = true;
        this.callback(null, this.saveResult);
    }.bind(this);

    if (this.afterSaveEntities) {
        try {
            this.afterSaveEntities.bind(this)(success);
        } catch (err){
            err.message = "save failed in 'afterSaveEntities' with error '"+err.message+"'";
            this._raiseError(err);
        }
    } else {
        success();
    }
};

fn._raiseError = function(error) {
    if (this._isAllDone) return;
    this._isAllDone = true;
    this.callback(error);
};

///// Private functions //////
function createGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function extend(target, source) {
    if (!source) return target;
    for (var name in source) {
        if (source.hasOwnProperty(name)) {
            target[name] = source[name];
        }
    }
    return target;
}

function formatEntityKey(ek) {
    return ek.entityTypeName + ": " + ek._id;
}



var Sequelize = require('sequelize');
var Promise = require("bluebird");

var _ = Sequelize.Utils._;
module.exports = SequelizeSaveHandler;

function SequelizeSaveHandler(sequelizeManager, req, callback) {
  var reqBody = req.body;
  this.sequelizeManager = sequelizeManager;
  this.metadataStore = sequelizeManager.metadataStore;
  this.entities = reqBody.entities;
  this.saveOptions = reqBody.saveOptions;
  this.callback = callback;
  // this.saveMap - created later

  this._keyMappings = [];
  this._fkFixupMap = {};
  this._savedEntities = [];
  this._entitiesCreatedOnServer = [];


};

var ctor = SequelizeSaveHandler;

ctor.save = function(db, req, callback) {
  var saveHandler = new SequelizeSaveHandler(db, req, callback);
  saveHandler.save().then(function(r) {
    return r;
  }).catch(function(e) {
    throw e;
  });
};

// virtual method - returns nothing
//MongoSaveHandler.prototype.beforeSaveEntity = function(entity)


// virtual method - returns saveMap - saveMap is keyed by entityType with each value being an array of entities.
//MongoSaveHandler.prototype.beforeSaveEntities = function(callback)


ctor.prototype.save = function() {
  var beforeSaveEntity = (this.beforeSaveEntity || noopBeforeSaveEntity).bind(this);

  // create the saveMap (entities to be saved) grouped by entityType
  this.saveMap = groupBy(this.entities, function(entity) {
    if (beforeSaveEntity(entity)) {
      return entity.entityAspect.entityTypeName;
    }
  });

  var beforeSaveEntities = (this.beforeSaveEntities || noopBeforeSaveEntities).bind(this);
  // beforeSaveEntities(this._saveCore.bind(this));
  var that = this;
  return this._saveCore().then(function(savedEntities) {
    return { entities: savedEntities, keyMappings: that._keyMappings };
  }).catch(function(e) {
    throw e;
  });
};

function noopBeforeSaveEntities(fn) {
  fn();
}

function noopBeforeSaveEntity(entity) {
  return true;
}

// will be bound to SequelizeSaveHandler instance at runtime.
ctor.prototype._saveCore = function() {
  var that = this;
  return Promise.reduce(_.pairs(this.saveMap), function(savedEntities, pair) {
    // pair[0] will be entityTypeName
    // pair[1] will be array of entities
    return that._processEntityGroup(pair[0], pair[1]).then(function(entities) {
      Array.prototype.push.apply(savedEntities, entities);
      return savedEntities;
    });
  }, []);

  // need to fixupFks after this

};


// Need to handle
// entityKey._id may be null/undefined for entities created only on the server side - so no need for keyMapping

// returns a promise containing resultEntities array when all entities have been saved.
// will be bound to this later
ctor.prototype._processEntityGroup = function(entityTypeName, entities) {

  var entityType = this.metadataStore.getEntityType(entityTypeName);
  if (!entityType) {
    this._raiseError(new Error("Unable to locate server side metadata for an EntityType named: " + entityTypeName));
  }
  var sqModel = this.sequelizeManager.entityTypeSqModelMap[entityTypeName];

//  Promise.reduce(["file1.txt", "file2.txt", "file3.txt"], function(total, fileName) {
//    return fs.readFileAsync(fileName, "utf8").then(function(contents) {
//      return total + parseInt(contents, 10);
//    });
//  }, 0).then(function(total) {
//    //Total is 30
//  });

  var that = this;
  return Promise.reduce(entities, function(savedEntities, entity) {
    // function returns a promise for this entity
    // and updates the results array.
    return that._saveEntityAsync(entity, entityType, sqModel).then(function(savedEntity) {
      savedEntities.push(savedEntity);
      return savedEntities;
    });
  }, []);

};

// returns a promise with the saved entity
ctor.prototype._saveEntityAsync = function(entity, entityType, sqModel) {
  // function returns a promise for this entity
  // and updates the results array.
  var that = this;
  // not a "real" entityAspect - just the salient pieces sent from the client.
  var entityAspect = entity.entityAspect;
  // just to be sure that we don't try to send it to the server or return it to the client.
  delete entity.entityAspect;
  var entityTypeName = entityType.name;
  // needed because we need to strip the entityAspect off the entity for inserts.
  entityAspect.entity = entity;

  // TODO: we really only need to coerce every field on an insert
  // only selected fields are needed for update and delete.
  this._coerceData(entity, entityType);
  var keyProperties = entityType.keyProperties;
  var firstKeyPropName = keyProperties[0].nameOnServer;

  var entityState = entityAspect.entityState;
  if (entityState === "Added") {


    var autoGeneratedKeyType = entityType.autoGeneratedKeyType;
    var keyMapping = null;
    if (autoGeneratedKeyType && autoGeneratedKeyType.name !== "None") {
      var tempKeyValue = entity[firstKeyPropName];
      var keyDataType = entityType.keyDataType;
      if (keyDataType === "Guid") {
        // handled here instead of one the db server.
        var realKeyValue = createGuid();

        entity[firstKeyPropName] = newKeyValue;
        keyMapping = { entityTypeName: entityTypeName, tempValue: tempKeyValue, realValue: realKeyValue };
      } else {
        // realValue will be set during 'create' promise resolution below
        keyMapping = { entityTypeName: entityTypeName, tempValue: tempKeyValue, realValue: null };
        // value will be set by server's autoincrement logic
        delete entity[firstKeyPropName];
      }
    }
    return sqModel.create(entity).then(function(savedEntity) {
      if (keyMapping) {
        if (keyMapping.realValue === null) {
          keyMapping.realValue = savedEntity[firstKeyPropName];
        }
        var tempKeyString = buildKeyString(entityType, tempKeyValue);
        that._fkFixupMap[tempKeyString] = keyMapping.realValue;
        that._keyMappings.push(keyMapping);
      }
      return that._addToResults(savedEntity.values, entityTypeName);
    }).catch(handleItemSaveError(entity, entityState));

  } else if (entityState === "Modified") {
    var whereHash = {};
    keyProperties.forEach(function (kp) {
      whereHash[kp.nameOnServer] = entity[kp.nameOnServer];
    });

    if (entityType.concurrencyProperties && entityType.concurrencyProperties.length > 0) {
      entityType.concurrencyProperties.forEach(function (cp) {
        whereHash[cp.nameOnServer] = entityAspect.originalValuesMap[cp.nameOnServer];
      });
    }
    var setHash;
    if (entityAspect.forceUpdate) {
      setHash = extend({}, entity);
      // remove fields that we don't want to 'set'
      delete setHash.entityAspect;
    } else {
      setHash = {};
      Object.keys(entityAspect.originalValuesMap).forEach(function (k) {
        setHash[k] = entity[k];
      });
    }
    var that = this;
    return sqModel.update(setHash, { where: whereHash }).then(function(savedEntity) {
      // HACK: Sequelize 'update' does not return the entity; so
      // we are just returning the original entity here.
      return that._addToResults(entity, entityTypeName);
    }).catch(handleItemSaveError(entity, entityState));
  } else if (entityState = "Deleted") {
    var whereHash = {};
    keyProperties.forEach(function (kp) {
      whereHash[kp.nameOnServer] = entity[kp.nameOnServer];
    });
    // we don't bother with concurrency check on deletes
    // TODO: we may want to add a 'switch' for this later.
    return sqModel.destroy({ where: whereHash, limit: 1}).then(function() {
      // Sequelize 'destroy' does not return the entity; so
      // we are just returning the original entity here.
      return that._addToResults(entity, entityTypeName);
    }).catch(handleItemSaveError(entity, entityState))
  }
};

function handleItemSaveError(entity, entityState) {
  return function(err) {
    err = typeof(err) == 'string' ? new Error(err) : err;
    err.entity = entity;
    err.entityState = entityState;
    throw err;
  }
}

ctor.prototype._addToResults = function(entity, entityTypeName) {
  entity.$type = entityTypeName;
  this._savedEntities.push(entity);
  // return Promise.resolve(entity);
  return entity;
};

ctor.prototype._addToSaveMap = function(entity, entityTypeName, entityState) {
  var entityTypeName = this.qualifyTypeName(entityTypeName);
  entity.entityAspect = {
    entityTypeName: entityTypeName,
    entityState: entityState || "Added",
    wasCreatedOnServer: true
  };

  var entityList = this.saveMap[entityTypeName];
  if (entityList) {
    entityList.push(entity);
  } else {
    this.saveMap[entityTypeName] = [ entity ];
  }

  return entity;
};


ctor.prototype._coerceData = function(entity, entityType) {
  var that = this;
  entityType.dataProperties.forEach(function(dp) {
    var dt = dp.dataType;

    var val = entity[dp.nameOnServer];
    if (val && dp.relatedNavigationProperty != null) {
      // if this is an fk column and it has a value
      // check if there is a fixed up value.
      var key = buildKeyString(dp.relatedNavigationProperty.entityType, val);
      var newVal = that._fkFixupMap[key];
      if (newVal) {
        entity[dp.nameOnServer] = newVal;
      }
    }

//    if (val == null) {
//      // this allows us to avoid inserting a null.
//      // TODO: think about an option to allow this if someone really wants to.
//      delete entity[dp.name];
//      return;
//    }

    var dtName = dt.name;
    if (val && dtName === "DateTime" || dtName === "DateTimeOffset") {
      entity[dp.nameOnServer] = new Date(Date.parse(val));
    }
  })
}

function buildKeyString(entityType, val) {
  return entityType.name + "::" + val.toString();
}

//function fixupFks(pcs) {
//  if (this._keyMappings.length === 0) return;
//  // pendingMap is a map of _id to pendingDoc
//  var pendingMap = {};
//  pcs.forEach(function(pc) {
//    pc.inserts.concat(pc.updates).forEach(function(doc) {
//      pendingMap[doc.entityAspect.entityKey._id] = doc;
//    })
//  });
//
//  // kmMap is a map of tempFkValue -> keyMapping
//  var kmMap = {};
//  this._keyMappings.forEach(function(km) {
//    kmMap[km.tempValue] = km;
//  });
//
//  // _possibleFixupMap is a map of fkValue -> [] of possibleFixups { _id:, fkProp: }
//  for (fkValue in this._possibleFixupMap) {
//    var km = kmMap[fkValue];
//    if (km) {
//      // if we get to here we know that we have an fk or fks that need updating
//      var realValue = km.realValue;
//      var pendingFixups = this._possibleFixupMap[fkValue];
//      pendingFixups.forEach(function(pendingFixup) {
//        // update the pendingDoc with the new real fkValue
//        // next line is for debug purposes
//        pendingFixup.fkValue = realValue;
//        var pendingDoc = pendingMap[pendingFixup._id];
//        if (pendingDoc.criteria) {
//          pendingDoc.setOps.$set[pendingFixup.fkProp] = realValue;
//        } else {
//          pendingDoc.entity[pendingFixup.fkProp] = realValue;
//        }
//      });
//    }
//  }
//};

ctor.prototype._raiseError = function(error) {
  if (this._isAllDone) return;
  this._isAllDone = true;
  this.callback(error);
};

ctor.prototype._checkIfError = function(err) {
  if (err) {
    this._raiseError(err);
  }
  return err != null;
};

function extend(target, source) {
  if (!source) return target;
  for (var name in source) {
    if (source.hasOwnProperty(name)) {
      target[name] = source[name];
    }
  }
  return target;
}

// returns an array with each item corresponding to the kvFn eval'd against each prop.
function objectMap(obj, kvFn) {
  var results = [];
  for (var key in obj) {
    if ( obj.hasOwnProperty(key)) {
      var r = kvFn(key, obj[key]);
      results.push(r);
    }
  }
  return results;
}

function groupBy(arr, keyFn) {
  var groups = {};
  arr.forEach(function (v) {
    var key = keyFn(v);
    if (key !== undefined) {
      var group = groups[key];
      if (!group) {
        group = [];
        groups[key] = group;
      }
      group.push(v);
    }
  })
  return groups;
}

function createGuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Not needed.
//// task is a function that returns a promise.
//function sequencePromises(tasks) {
//  var current = Promise.resolve(), results = [];
//  for (var k = 0; k < tasks.length; ++k) {
//    results.push(current = current.then(tasks[k]));
//  }
//  return Promise.all(results);
//}
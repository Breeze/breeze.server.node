import { Sequelize, Options, SyncOptions } from "sequelize";
import { MetadataStore, DataProperty, breeze } from "breeze-client";
import { ModelLibraryBackingStoreAdapter } from "breeze-client/adapter-model-library-backing-store";
import { DbConfig, createDb } from "./dbUtils";
import { MetadataMapper, NameModelMap } from "./MetadataMapper";

import * as _ from 'lodash';
import * as utils from "./utils";
import { ModelMapper } from "./ModelMapper";
const log = utils.log;

export interface KeyGenerator {
  getNextId: (prop: DataProperty) => any;
}

/** Manages the Sequelize instance for Breeze query and save operations */
export class SequelizeManager {
  static Sequelize = Sequelize;
  sequelizeOptions: Options;
  dbConfig: DbConfig;
  sequelize: Sequelize;
  /** Same as resourceNameSqModelMap */
  models: NameModelMap;
  /** Maps resource name to Sequelize Model */
  resourceNameSqModelMap: NameModelMap;
  /** Maps entity type name to Sequelize Model */
  entityTypeSqModelMap: NameModelMap;
  metadataStore: MetadataStore;
  /** Generates keys for entity types where autoGeneratedKeyType = "KeyGenerator" */
  keyGenerator: KeyGenerator;

  constructor(dbConfig: DbConfig, sequelizeOptions: Options) {
    const defaultOptions: Options = {
      dialect: "mysql", // or 'sqlite', 'postgres', 'mssql'
      port: 3306, // (mysql), or 5432 (postgres), 1433 (mssql)
      // omitNull: true,
      logging: false,
      dialectOptions: { decimalNumbers: true },
      define: {
        freezeTableName: true,  // prevent sequelize from pluralizing table names
        timestamps: false       // deactivate the timestamp columns (createdAt, etc.)
      }
    };
    const define = defaultOptions.define;
    this.sequelizeOptions = _.extend(defaultOptions, sequelizeOptions || {});
    this.sequelizeOptions.define = _.extend(define, (sequelizeOptions && sequelizeOptions.define) || {});
    this.dbConfig = dbConfig;
    this.sequelize = new Sequelize(dbConfig.dbName, dbConfig.user, dbConfig.password, this.sequelizeOptions);
    log.enabled = !!this.sequelizeOptions.logging;
    ModelLibraryBackingStoreAdapter.register(breeze.config);
  }

  /** Connect to the database */
  async authenticate(): Promise<void> {
    // check database connection
    try {
      await this.sequelize.authenticate();
      log('Connection has been established successfully.');
    } catch (err) {
      log('Unable to connect to the database:', err);
      throw err;
    }
  }

  /** Create a new database */
  createDb() {
    return createDb(this.dbConfig, this.sequelizeOptions);
  }

  /** Import Sequelize models, create Breeze metadata from the models, and build the maps between them. */
  importModels(modelDir: string, namespace: string) {
    // load models into sequelize instance
    ModelMapper.loadSequelizeModels(this.sequelize, modelDir);

    // add models to the metadata store
    this.metadataStore = new MetadataStore();
    const mm = new ModelMapper(this.metadataStore);
    mm.addModels(this.sequelize, namespace);

    // create maps between the metadata and the models
    this.importMetadata(this.metadataStore);
  }

  /** Convert Breeze metadata to Sequelize models */
  importMetadata(breezeMetadata: MetadataStore | string | Object) {
    const metadataMapper = new MetadataMapper(breezeMetadata, this.sequelize);
    // TODO: should we merge here instead ; i.e. allow multiple imports...
    this.models = this.resourceNameSqModelMap = metadataMapper.resourceNameSqModelMap;
    this.entityTypeSqModelMap = metadataMapper.entityTypeSqModelMap;
    this.metadataStore = metadataMapper.metadataStore;
  }

  /** Sync the Sequelize model with the database */
  async sync(shouldCreateDb: boolean, sequelizeOpts: SyncOptions) {
    if (shouldCreateDb) {
      await this.createDb();
    }
    return await this.syncCore(this.sequelize, sequelizeOpts);
  }

  private async syncCore(sequelize: Sequelize, sequelizeOpts: SyncOptions)  {
    const defaultOptions = { force: true };
    sequelizeOpts = _.extend(defaultOptions, sequelizeOpts || {});

    try {
      await sequelize.sync(sequelizeOpts);
      log("schema created");
      return sequelize;
    } catch (err) {
      console.log("schema creation failed");
      throw err;
    }

  }
}


import { Entity, EntityState, EntityType, StructuralType } from "breeze-client";
import { SequelizeSaveHandler } from "./SequelizeSaveHandler";

export type EntityStateString =  "Added" | "Deleted" | "Modified";


/** Server-side representation of entity that came from the client */
export interface EntityInfo {
  entity: Entity;
  entityType: EntityType;
  wasAddedOnServer?: boolean;
  forceUpdate?: boolean;
  unmapped?: any;
  entityAspect: {
    entityTypeName: string;
    entityState: EntityStateString;
    entity?: Entity;
    autoGeneratedKey?: {
      autoGeneratedKeyType: string;
    }
    originalValuesMap?: { [prop: string]: any };
  };
}

/** Validation error created on the server */
export interface ServerEntityError {
  entityTypeName: string;
  errorName: string;
  errorMessage: string;
  propertyName: string;
  keyValues: any[];
}

/** Maps EntityType names to arrays of EntityInfo */
export class SaveMap {
  private sequelizeSaveHandler: SequelizeSaveHandler;
  entityErrors: ServerEntityError[];
  errorMessage: string;

  constructor(sequelizeSaveHandler: SequelizeSaveHandler) {
    // make sequelizeSaveHandler non-enumerable so it won't be in Object.keys()
    Object.defineProperty(this,  "sequelizeSaveHandler", { value: sequelizeSaveHandler });
  }

  getEntityType(entityTypeName: string): StructuralType {
    return this.sequelizeSaveHandler.metadataStore.getEntityType(entityTypeName);
  }

  getEntityInfosOfType(entityTypeName: string): EntityInfo[] {
    const entityType = this.getEntityType(entityTypeName);
    // entityType.name is fully qualified.
    return this[entityType.name] || [];
  }

  /** Add an entity to the map */
  addEntity(entityTypeName: string, entity: object, entityState: EntityStateString = "Added" ): EntityInfo {
    const entityType = this.getEntityType(entityTypeName);
    entityTypeName = entityType.name; // fully qualified now.
    const entityInfo = {
      entity: entity, entityType: entityType, wasAddedOnServer: true,
      entityAspect: {
        entityTypeName: entityTypeName,
        entityState: entityState
      }
    } as EntityInfo;
    const entityInfoList = this[entityTypeName];
    if (entityInfoList) {
      entityInfoList.push(entityInfo);
    } else {
      this[entityTypeName] = [entityInfo];
    }
    return entityInfo;
  }

  /** Add an error to the entityErrors collection */
  addEntityError(entityInfo: EntityInfo, errorName: string, errorMessage: string, propertyName: string) {
    if (!this.entityErrors) {
      this.entityErrors = [];
    }

    const entityType = entityInfo.entityType;
    const keyValues = entityType.keyProperties.map(kp => {
      return entityInfo.entity[kp.nameOnServer];
    });
    this.entityErrors.push({
      entityTypeName: entityType.name,
      errorName: errorName,
      errorMessage: errorMessage,
      propertyName: propertyName,
      keyValues: keyValues
    });
  }

  /** Set the error message to return to the client */
  setErrorMessage(errorMessage: string) {
    this.errorMessage = errorMessage;
  }
}

